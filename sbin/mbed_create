#!/usr/bin/python

import sys, os, glob
import getopt
import re
import json
import mbed_util, config

_mbed_path = config.mbed_path
_mbed_libs_path = config.mbed_libs_path
_mbed_rel_path = config.mbed_rel_path

_tpl_makefile_ext = """# WARNING: DO NOT MODIFY !
# This file is generated by mbed_create.
# For more informations, type "mbed_create -h"

MBED_PATH = $(MBED_PATH)
PROJECT = $(PROJECT)
EXT_O = $(EXT_O)
EXT_I = $(EXT_I)
GCC_BIN = $(GCC_BIN)

"""

_tpl_main = """// This file is generated by mbed_create.
// For more informations, type "mbed_create -h"

#include "mbed.h"

int main() {
    printf("Hello World !\\n");
    while (true) {
    }
    return 0;
}
"""

_help_text = """Create a mbed project

Usage:
mbed_create <project_name> [args]

Arguments:

-h: 
    Show this help message

-p <platform>:
    Specify the platform. If not specified, the first avaiable platform will be used.
    Available platforms are:
    NUCLEO_F401RE

-l <lib_name>|<lib_path>:
    Include a library. If library name (a string not containing '/' or '\\' is a library name) specified, the default libraries in ~/work/mbed/libs will be searched. Else the path will be used.
    This option can be used for more than one time.
"""

# prepare options
if len(sys.argv) < 2:
    print "**Error**\n\tMust specify a project name."
    sys.exit();
project_name = sys.argv[1]
if (re.compile('[^a-zA-Z0-9_]').search(project_name)):
    print "**Error**\n\tProject name not valid."
    sys.exit();
include_libs = []
platforms_available = ['nucleo_f401re']
platform = platforms_available[0]
opts, args = getopt.getopt(sys.argv[2:], "hp:l:")
for o, a in opts:
    if o in ['-h']:
        print _help_text
        sys.exit()
    elif o in ['-p']:
        a_tmp = lower(a)
        if a_tmp in platforms_available:
            platform = a_tmp
        else:
            print "**Error**\n\tPlatform not avaiable."
            sys.exit()
    elif o in ['-l']:
        path = a
        if (path.find('/') < 0) and (path.find('\\') < 0):
            path = _mbed_libs_path + path
        path = os.path.realpath(path)
        include_libs.append(path)

if os.path.exists("./" + project_name):
    print "**Error**\n\tProject directory already exist!"
    sys.exit()

mbed_path = _mbed_rel_path + platform
if not os.path.exists(mbed_path):
    print "**Error**\n\tPlatform not avaiable."
    sys.exit()

(ext_i, ext_o) = mbed_util.parse_include_libs(include_libs)

makefile_content = _tpl_makefile_ext \
    .replace("$(MBED_PATH)", mbed_path) \
    .replace("$(PROJECT)", project_name) \
    .replace("$(EXT_O)", " ".join(ext_o)) \
    .replace("$(EXT_I)", " ".join(ext_i)) \
    .replace("$(GCC_BIN)", config.gcc_bin)

makefile_tpl_file = open(mbed_path + '/makefile_tpl')
makefile_content = makefile_content + makefile_tpl_file.read()
makefile_tpl_file.close()

package_info = {
    "name": project_name,
    "platform": platform,
    "libs": include_libs
}
package_info = json.dumps(package_info)

os.mkdir("./" + project_name)
makefile_file = open("./" + project_name + "/Makefile", 'w')
makefile_file.write(makefile_content)
makefile_file.close()
mainc_file = open("./" + project_name + "/main.cpp", 'w')
mainc_file.write(_tpl_main)
mainc_file.close()
package_json_file = open("./" + project_name + "/package.json", 'w')
package_json_file.write(package_info)
package_json_file.close()

print "Project " + project_name + " created !"







